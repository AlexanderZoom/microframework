# MicroFramework 
Данное приложение - это сбор библиотек вокруг архитектуры MVC. Как таковая библиотека не является фреймворком, т.к. все ее классы не предназначены для наследования в приложение проекта и понятие приложение проекта не заложено в архитектуру библиотеки. Эта библиотека хорошо подходит под мини проекты (лендинг, парсер, страница-визитка и подобное).

## Возможности
- Обращение к библиотеке через ЧПУ или непосредственно через созданные файлы.
- Псевдо-роутинг - так я его назвал, т.к. самого класса роутинга с привычными маршрутами нет, но есть класс, который разбирает строку запроса и раскладывает данные по переменным и передает их в контроллер для дальнейшей работы, но об этом я расскажу позже.
- MVC
- БД (mysql, есть возможность добавить другие адаптеры бд)
- DataMapping
- 404 страница
- Обработка ошибок с выводом отладочной информации на экран
- Крон-контроллер - возможность запускать крон скрипты
- Вкл/выкл сайта и фоновых скриптов при помощи одного изменения в конфиге
- Автолоадинг

## Файловая структура
```
/inc - корневая директория библиотеки
-/Ctrl - директория контроллеров
-/Data - директория для хранения всевозможных данных
-/Lib  - директория каркаса библиотеки
-/Model - директория моделей
-/View - директория представлений
-/View/Ctrl - директория представлений контроллеров
-/.htaccess - запрет просмотра директории inc
-/common.php - сборочный файл библиотеки
-/config.php - файл с настройками
-/cron.php - запуск фоновых приложений
.htaccess - включение ЧПУ
index.php - исполняемый файл со стороны вэб
```

Именование файлов начинается с заглавной буквы и с той директории в которую вы положили, после директории inc .

(пример: вам нужен контроллер `main`, тогда вы создаете файл `Main.php` в директорию `Ctrl`, а имя класса будет звучать `Ctrl_Main`)

## Конфиг
```php
$_GLOBAL_CONFIG = array(
            'app_time_zone'    => 'Europe/Moscow',  // установка часового пояса
            'app_charset'         => 'utf-8', // установка кодировки для внутренних нужд библиотеки
            'app_path_inc'	   => dirname(__FILE__), // путь корневой папки библиотеки
            'app_path_lib'	   => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'Lib', // путь каркаса библиотеки
            'app_path_ctrl'	   => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'Ctrl', //путь папки контроллеров
            'app_path_model'	   => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'Model', //путь папки моделей
            'app_path_view'	   => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'View', //путь папки представлений
            'app_disable_page' => '', // путь файла, который используется при отключении сайта (если файл не указан, то выводится текстовое сообщение)
            'app_exception_display' => '1', // вывод отладочной информации на экран
            'app_rewrite_rules' => 1, // переменная сигнализирует классу по разбору запроса (Lib/ParseRequest.php), что включено ЧПУ
            'app_ctrl_error' => 'error',  //Контроллер 404 ошибки
            'app_main_template' => 'main', // Основной декоратор представлений
    
            'php_log'                => '', // сбор php-логов в отделный файл
            'php_log_errors'      => '1',
            'php_error_reporting'   => E_ALL, // тип выводимых ошибок
            'php_display_errors'    => 1, // вывод системных ошибок на экран
    
    
            'site_enable'          => 1, // вкл/выкл библиотеки
    
            'db' => array( //секция для подключения к бд, является не обязательной, т.е. реализация бд не встроена в диспетчер библиотеки, а подключается отдельно
                'server_type' => 'mysql', // тип адаптера
                'host' => 'localhost', 
                'user' => 'root',
                'pass' => 'god',
                'dbname' => 'mysql',
                'charset' => 'utf8',
            ),
                
    );
```

## Логика обработки запроса
Вся логика лежит в файле `/Lib/Dispatcher.php`

Вкратце, дело обстоит так:
- приходит запрос на страницу
- индексный файл подключает `common.php`
- `common.php` выполняет необходимые действия для корректной работы и запускает диспетчер `Lib_Dispatcher`
- внутри диспетчера
-- инициализация
-- проверяется влючен ли сайт
-- разбирается входная строка запроса классом `Lib_ParseRequest`, который возвращает массив с данными для дальнейшей работы системы


Дальнейшее выполнение задачи делится на `простой запуск` диспетчера и `запуск с использованием данных` , которые были получены в результате работы `Lib_ParseRequest`.

`Простой запуск` необходим, для отдельных индексных файлов (`index.php, second.php, etc`) чтобы запустить определнный контроллер с определенным действием. 
Чтобы `простой запуск` начал работать необходимо создать отдeльный файл рядом с index.php` и вставить текст, который представлен ниже:

```php
<?php
$_APPLICATION_SIMPLE = true; // эта переменная отключает автоматический вызов метода forward в диспетчере и тем самым мы можем указать, что мы будет исполнять
require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'inc' . DIRECTORY_SEPARATOR . 'common.php');
$dispatcher->forward($ctrlName='', $actionName = '', $statusCode = 200);
?>
```

```
$ctrlName='', - название контроллера 
$actionName = '',  - название метода в контроллере
$statusCode = 200  - http код выходной страницв
```

`Запуск с использованием данных` происходит от файла index.php, дополнительных действий этот способ выполнения не требует, метод forward запускается автоматически.

## Логика работы метода forward
- Определяется название контроллера, если переменная контроллера оказалась пустой, то устанавливается предопределенное имя `main`, это основное имя контроллера
- Дальше идет проверка на существование контроллера. Если он не существует, то система перенаправляет запрос на `Lib_Config::getVar('app_ctrl_error')` - 404 ошибку (если 404 контроллера не будет, то произойдет зацикливание и после `$this->nestingForwardCount >= $this->nestingForward` приложение упадет в ошибку)
- Создается класс контроллера и передаются остальные параметры внутрь контроллера, т.е. внутри контроллера решается дальнейший роутинг, при помощи метода `init`, в котором можно описать, что делать дальше.
- Исполняется контроллер
- Рендерится страница 
- Вывод данных
- Exit

## Логика выполнения действия (`action`)
В контроллере для вэб (`Lib_Ctrl_Web` - родительский класс для всех вэб контроллеров).


Если в метод forward не был передан `$actionName`, то за установку текущего действия отвечает метод `init` в текущем контроллере.
Но до этого контроллер выполняет несколько проверок в конструкторе класса:
- Проверка на количество доп. параметров переданных в строке запроса делается в методе `_checkParam`, если метод возвращает ложь, то идет перенаправление на 404.
  Это действие необходимо для того чтобы точно определить строку запроса для данного контроллера. К примеру, пришел запрос `http://localhost/main/show`, парсер запроса определил контроллер (`main`) и передал остальные параметры (в данном случем он один - `show`) в контроллер
  Если нам нужен этот параметр, то тогда метод `_checkParam` должен вернуть `true`, а если нет , то `false` и пользователь автоматом попадет на 404 страницу.
  Несмотря на то, что это откровенные костыли, я хотел бы подчеркнуть, что это лучше по скорости чем стандартный роутинг, который предлагается в известных фреймворках, а для задач этого микрофреймворка, очень редко могут понадобиться доп. параметры. Поэтому данный костыль можно потрепеть.
- Проверка расширения в конце строки запроса `http://localhost/main/show.html` регулируется `$availableFormats = array('html');` само расширение является не только красивым дополнением, но также влияет на представление, какое именно будет использовано, т.е. имя представления если формат не html выглядит так - `{имя контроллера}{действие-исполняемый метод}{расширение}.php (MainIndex.json.php)`, тоже самое с декоратором представления, только без "действие-исполняемый метод" `(General.json.php)`

	
## Работа с БД
Подключение бд к дефолтной библиотеке осуществляется в файле `common.php`	
```php
////////////////////////DB ////////////////////
    if (Lib_Config::getVar('site_enable') && Lib_Config::hasVar('db')){
        $db = Lib_DbConnectionManager::initDb(Lib_Config::getVar('db'));
        
        Lib_DataMapper::initInstance($db);
    }
///////////////////////////////////////////////
```
Вызвать обертку и выполнить запрос можно из любого места:
```php
//$db = Lib_DbConnectionManager::getDb();
//$queryObj = $db->getQuery();
//$this->rows = $queryObj->query('SHOW TABLES')->fetchRows();
```
Также реализован DataMapping, пример работы:
```php
$dm = Lib_DataMapper::getInstance();
        
$model1 = new Model_Test();
$model1->name = 'Vasya';
$dm->save($model1); // данный метод выполняет добавление или обновление записи
        
$model2 = new Model_Test();
$model2->name = 'Petya';
$dm->add($model2); // пытается добавить запись
$dm->update($model2); // пытается обновить запись
$model->loaded(); // метод возвращает булевое значение true - если запись есть в бд, в противном случае false, корректно работает после загрузки данных в модель, к примеру при помощи датамапера, пример загрузки вы можете посмотреть в файле /Lib/DataMapper/Default.php

$model = $dm->loadTest(1); // данный метод является кастомным и приведен в виде примера, он располагается в /Lib/DataMapper/Default.php (в дефолтном датамапинге, который был инициализирован выше в файле common.php Lib_DataMapper::initInstance($db);) 
//Вы можете создавать свои датамаперы в папке /Lib/DataMapper/
// Инициализировать Lib_DataMapper::initInstance($db, $label); $db - обертка бд, $label - название файла датамапинга, без расширения и с маленькой буквы
// И вызывать где угодно внутри библиотеки $dm = Lib_DataMapper::getInstance($label);

if (!$model->loaded()) $this->out = "not loaded"; // проверяем были ли загружены данные из бд
else {	
    $dm->delete($model); // удаление записи из бд
}
```

## Запуск фоновых-крон задач
Фоновые задачи выполняются в консоли запуском файла php inc/cron.php {короткое имя контроллера}
Рассмотрим пример:
```php
<?php
class Ctrl_CronMain extends Lib_Ctrl_Cli {
    
    public function index(){
        echo "Hello World\n";
    }
}
```
Особенности фоновых-крон задач:
- Все фоновые контроллеры лежат в общей папке для контроллеров
- Они не имеют представления
- Метод на исполнение всегда `index` 
- родительский класс контроллера фоновых-крон задач - `Lib_Ctrl_Cli`


Короткое имя контроллера `Ctrl_CronMain` - `main`, имя файла данного контроллера `CronMain.php`
